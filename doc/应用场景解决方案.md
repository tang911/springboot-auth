支付修改状态时需要加 status = 0, 由初始状态变为终态。
组合支付积分+现金，支付回调和接口返回。
系统如何做到积分的到期即失效，有系统生成tradeTime,在后续调用链中传递参数。


#### 1 电商平台订单未支付超时自动关单
定时任务执行 
jdk 延迟队列 delayQueue
redis 过期监听
redisson 分布式延迟队列
rocketmq 延迟队列
rabbitmq 死信队列

#### 2 如何设计一个秒杀系统
并发编程的三个核心问题: 可见性 有序性 原子性
并发的三大利器 缓存 限流 降级
架构的原则 高可用 高并发 高扩展 高负载

秒杀系统本质是一个高并发、高性能和高可用的分布式系统。
秒杀主要解决并发读和并发写的问题。
秒杀系统的院子 4要1不要
1 数据要尽量的少
2 请求要尽量的少
3 路径要尽量的短
4 依赖要尽量的少
5 不要有单点

独立的秒杀系统
动静分离
动静数据说的不是数据本身是否变动而是根据访问者的不同而其个性化数据。

缓存放在距离用户最近的位置，使用web服务器，nginx apache 
动静分离的方案：单机部署方案，统一cache层，上CDN

动静分离怎么做
流量削峰怎么做，预约抢购资格，答题，滑块验证码，兜底方案
秒杀系统怎么扣减库存

iops 系统的读写性能，系统的每秒读写次数
rt
qps
扣减库存的设计 下单扣库存 付款扣库存 预扣库存 限购模式
库存扣减通过数据库事先，需要对秒杀商品加锁，库存不能为负数。
库存扣减通过redis实现，异步写入数据库中，库存可以进一步拆分，使用redis集群分散读写压力。

#### 4 系统的QPS 突然提升10 倍
1 硬件的扩展以及微服务的拆分
2 使用高性能的RPC, Feign 带负载均衡、熔断降级的机制
3 消息队列削峰解耦
4 使用缓存架构
5 数据库分库分表
6 高可用的系统

#### 5 10W的QPS会员系统
1 ES集群实现系统查询的高可用
2 使用redis缓存数据
3 使用分库分表数据库
4 限流和降级策略

#### 6 高并发的优惠券系统
创建券模板，发放优惠券，优惠券核销与反核销，优惠券过期


#### 8 短链系统如何设计
短链生成的方法
1 单向散列函数，md5,sha, base64,截取字符
2 自增长短链
3 预生成短链模式
4 

微博分库分表策略 根据用户id 取模分库分表,设置用户每天发微博的限制数量。


#### 14 如何避免超预期的高并发压力压垮系统
限流配置文件本地配置和远程配置，远程高于本地。
1 限流方式:  全局限流 账号限流 设备限流 资源限流
2 限流算法： 固定窗口 Window，滑动窗口 Sliding Window，漏斗 Leaky Bucket，令牌桶 Token Bucket

实践中可以采用队列当做漏斗

#### 17 你设计一个支持千万级流量的架构
前端优化：减少请求次数、页面静态化、边缘计算。
前端加缓存，Cache-Control 图片请求次数 减少脚本请求次数
后端优化 基础设施层面、网络层面、架构层

rpc 框架 提升网络传输性能  选择合适的序列化方式
网络性能提升 dubbo,合适的序列化框架 Thrift Protobuf

rocketmq 发送局部有序消息，使用 producer.send 发送消息时需要实现 MessageQueueSelector 接口，自定义queue序列


SPU：标准产品单元（Standard Product Unit）
SKU：库存单位（Stock Keeping Unit
SKC：库存颜色单位（Stock Keeping Color）
SPU代表单款商品。
SKU代表单款单色单码。
SKC代表单款单色。


底层服务要抽象

#### 26 库存抢购超卖少买问题
修改库存需要携带版本信息，防止出现ABA问题


#### 28 链路追踪系统

常见监控系统主要有三种类型：Metrics、Tracing 和Logging

Jaeger、Zipkin、Pinpoint、Skywalking

traceId  请求唯一标识
spanId  依赖层级
RPCID  层级计数器

自律的表现 勤勉 耐心 艰苦




表现层 逻辑层 数据访问层

OSI 七层网络模型 
物理层 数据链路层 网络层 传输层 会话层 表示层  应用层 
TCP/IP 四层模型
数据链路层 网络层 传输层 应用层

分层架构增加了代码的复杂性

#### 31 数据库是瓶颈，如何提高查询效率
1 使用缓存和缓冲区
2 数据分类缓存 Guava Cache 

#### 32 站内信未读消息
1 系统消息，缓存每一个消息的id，用户已经访问的消息id，之后的消息都是未读消息。展示消息点，可以设置消息时间戳，用户取消消息时间戳。
2 消息未读数量，每个用户的发消息数量，用户已经访问的消息数量，未读消息数量 = 发消息数量 - 访问消息数量，记录关注者的消息数量。


#### 33 java线上故障排查
1 常见问题 
内存 free -m 
cpu top
磁盘 df -h iostat lsof 
网络 dstat vmstat
jstatck jmap jvisualvm
netstat ifstat
中断（int）和上下⽂切换（csw)

arthas 

curl -O https://alibaba.github.io/arthas/arthas-boot.jar
java -jar arthas-boot.jar
jps jmap jstack jinfo 

-- 找到进行 查找线程
top -Hp pid
printf '%x\n' 22021
jstack 21993 | grep '0x5605' -A 50 --color

TPS 每秒处理数 
QPS 每秒查询数
HPS 每秒点击数

金融行业：1000 TPS~50000 TPS，不包括互联网化的活动
保险行业：100 TPS~100000 TPS，不包括互联网化的活动
制造行业：10 TPS~5000 TPS
互联网电子商务：10000 TPS~1000000 TPS
互联网中型网站：1000 TPS~50000 TPS
互联网小型网站：500 TPS~10000 TPS

SkyWalking
cpu 内存 磁盘 网络
STW 
ParNew CMS G1
忍辱负重
意识形态和实用工具

#### 36 敏感词过滤系统

DFS BFS 敏感词过滤系统

#### 37 微信抢红包
1 微信的金额是实时计算的，纯内存计算，预分配空间。
2 微信的红包金额的随机算法。

#### 40 消息堆积的排查思路
1 消息的生产、储存、消费三个阶段。
2 堆积消息: 增加消费者，优化消费者处理逻辑，清空堆积消息。
3 消息堆积导致cpu飚高的原因: 消息过多堆积、消费者无法及时处理消息，消息重试导致额外开销，过多的连接和网络io.


GC 配置参数
-Xmx2g
-XX:+HeapDumpBeforeFullGC
-XX:HeapDumpPath=.
-Xloggc:gc.log
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=10
-XX:GCLogFileSize=100m
-XX:HeapDumpOnOutOfMemoryError

查看数据库引擎状态
show engine innodb status
-- 开启标准监控
2 set GLOBAL innodb_status_output=ON;
3 -- 关闭标准监控
4 set GLOBAL innodb_status_output=OFF;
5 -- 开启锁监控
6 set GLOBAL innodb_status_output_locks=ON;
7 -- 关闭锁监控
8 set GLOBAL innodb_status_output_locks=OFF;
记录死锁日志，当发生死锁时，死锁日志会记录到MySQL的错误日志文件中
set GLOBAL innodb_print_all_deadlocks=ON;


#### 47 扫码登录的实现原理

扫码登录功能主要分为三个阶段：待扫描、已扫描待确认、已确认。



MQ投递延迟
传统定时任务

定时任务集群

实时性高 吞吐量大 服务稳定

如Lock、 CountDownLatch、Semaphore 等都用到了AQS.

cpu是电脑的计算资源，进程是分配单位，线程是执行单位。
cpu飚高的原因，cpu上线文切换过多，或者cpu资源过度消耗。

ConcurrentHashMap 在JDK1.8 中的存储结构，它是由数组、单向链表、红黑树组成。

二叉树 avl树 B树

tcp四元祖包括:源IP 地址、目标IP 地址、源端口号、目标端口号。



